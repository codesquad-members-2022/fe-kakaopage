## step-5 학습사항

### **1. REST API**

http의 강점을 살린 통신이 제대로 이루어지지 않아서  
등장하게 된 http의 강점을 살린 아키텍처 (이전 방식은 soap)

- REST의 기본을 지킨 서비스 디자인을 'RESTful'이라 칭한다.

- REST API란 REST를 기반으로 서비스 API를 구현한것을 칭한다.

uri 를 통해 자원을 나타내고  
(url - 자원의 위치, uri 자원 그자체, uri가 더 포괄적인개념이다. 이떄 동사의 사용을 금한다.)  
http method를 통해서 역할을 나타낸다.  
(get - 데이터 요청 / post - 데이터 생성 / delete - 데이터삭제 / put,patch - 데이터 수정)
이때 put, patch는 데이터 수정이므로 request body에 추가한다.

URL 구조
![](https://media.vlpt.us/images/jch9537/post/88b0c8ac-5870-4cbc-b613-7dd39f510f31/image.png)

---

### **2. PROMISE**

#### _프로미스 등장 배경_

- 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리중 발생한 에러의 처리가 곤란하다.

- ES6에서 비동기 처리를 위해 프로미스를 도입했다. 프로미스는 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점이 명확하다.

#### _프로미스는 생성자 함수다?_

Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스 객체를 생성한다.  
프로미스 생성자 함수는 비동기 처리를 수행할 콜백 함수 resolve와 reject 함수를 인수로 전달받는다.

프로미스 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행할때 비동기 처리가 성공하면  
인수로 전달받은 resolve 함수를 호출하고, 처리가 실패하면 reject 함수를 호출한다.

#### _프로미스의 상태 정보_

| 프로미스의 상태 정보 |                 의미                  |          상태 변경 조건          |
| :------------------: | :-----------------------------------: | :------------------------------: |
|       pending        | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
|       fulfiled       |    비동기 처리가 수행된 상태(성공)    |        resolve 함수 호출         |
|       rejected       |    비동기 처리가 수행된 상태(실패)    |         reject 함수 호출         |

#### _마이크로 태스크 큐?_

프로미스의 콜백함수는 콜백큐가 아닌 마이크로 태스크큐 (프로미스 잡 큐)에서 관리되며
이는 콜백 큐보다 우선순위가 높다.  
setTimeOut 0 초와 즉시 수행되는 프로미스 두가지가  
동시에 실행되면 프로미스 함수가 코드 위치상 밑에 있어도 먼저 실행된다.

![](https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif?w=600&h=272)

#### _프로미스 관련 메서드_

- Promise.all([]) -> 배열안의 프로미스를 한꺼번에 실행 하고 마지막 실행까지 기다린후 반환한다.
- Promise.Race([]) -> 여러 프로미스를 한꺼번에 돌리고 최초로 값을 반환하는 프로미스 발생시 그값을 리턴하고 종료한다.

이하 allsettled 등등 많다... 써봐야 알듯?

#### _프로미스 후속처리 메서드_

.then()을 사용하여 프로미스가 resolve/reject 를 반환한후 그 값을 다룰 수 있다.  
이때 .then()을 체이닝 하여사용도 가능하고, .catch()를 사용하여  
에러 핸들링 또한 유연하게 사용 가능하다.

#### _fetch_

이번 미션 핵심 기능이라 생각 한다. http 요청 전송 기능을 제공하는 클라이언트 사이드,  
Web Api로 XMLHttpRequest 객체보다 사용법이 간단하고 값으로 프로미스를 지원하기 떄문에
비동기 처리를 위해 콜백 패턴의 단점이 없다.

---

### **API 서버에서 요청별 URI 추출? 사용?**

query_string과 params? 등을 사용해야할것 같은데 이부분은 아직 학습이 미흡...!

---

### **CSR vs SSR**

전통적인 방식은 SSR방식이다. 이는 초기 화면로딩 진입속도가 빠르고(딱 필요한 index.html)만 다운로드 하기 때문  
필요한 요청마다. html 파일등을 서버에서 파일형태로 완성시켜 클라이언트에게 보내준다.

자연스럽게 서버와의 소통이 많고 트래픽이 혼잡해지며 서버에 과부화를 줄 수 있다.  
장점으로는 검색 엔진에 유리하다.

CSR은 컴퓨터보다 성능이 낮은 모바일 사용자들이 늘어나며 이런한 한계를 극복하기 위해 개발 됬으며

첫 화면에서 클라언트는 웹페이지에 필요한 정적 자원들을 전부 다운받게 된다.  
이후 클라이언트는 필요한 동적 자원을 서버에게 요청하고 서버는 데이터를 json형태로 넘겨 주기만한다.  
렌더링 작업은 각 자의 브라우저가 도맡아 하게되고 자연스럽게 서버와의 통신은 줄어들어  
네트워크작업 적인 자원소모가 줄어들고 서버의 과부화 또한 잡을 수 있다.  
단점으로는 첫 페이지 로딩이 길고 검색엔진에 불리하다.
